-- Создание таблицы

CREATE TABLE book (
	book_id  INT PRIMARY KEY AUTO_INCREMENT,
	title VARCHAR(50),
	author VARCHAR(30),
	price DECIMAL(8, 2),
	amount INT
);



-- Вставка данных в таблицу

INSERT INTO book (
	title,
	author,
	price,
	amount)
VALUES (
	"Мастер и Маргарита",
	"Булгаков М.А.",
	670.99,
	3);



-- IF STATEMENT

/* Для каждой книги из таблицы book установим скидку следующим образом:
 если количество книг меньше 4, то скидка будет составлять 50% от цены, в противном случае 30%.

В PostgreSQL вместо IF  используют конструкцию CASE ... WHEN ... THEN ... ELSE ... END  */

SELECT title, amount, price, 
    IF(amount<4, price*0.5, price*0.7) AS sale
FROM book;



/* Вывести название и автора тех книг, название которых состоит из двух и более слов, 
а инициалы автора содержат букву «С». 
Информацию отсортировать по названию книги в алфавитном порядке. */

SELECT
    title,
    author
FROM
    book
WHERE
    title LIKE "%_ %" AND author LIKE "%С.%"
ORDER BY
    title



-- Совмещение WHERE И HAVING
/* Вывести максимальную и минимальную цену книг каждого автора, 
кроме Есенина, количество экземпляров книг которого больше 10. */

SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;

/* ! Почему не стоит "засовывать" author <> 'Есенин С.А.' в HAVING:
Не смотря на то что результат будет одинаковым, так делать не рекомендуется. 
«Потому что как написано - запрос сначала выбирает всех авторов, 
потом выводит данные, рассчитывая минимальное и максимальное значение цены 
для каждого, и только после всего убирает Есенина. Можно убрать Есенина 
в данном случае раньше и не использовать ресурсы базы для расчета 
его минимального и максимального значения, как это сделано в первом варианте. 
На небольшой базе быстродействия не ощутить, но если выполнять такое 
на продуктивной, то второй вариант значительно проигрывает...» 

Последовательность выполнения операций на сервере:
MySQL: FROM => WHERE = SELECT = GROUP BY = HAVING = ORDER BY = LIMIT.   
PostgreSQL: FROM => WHERE = GROUP BY = HAVING = SELECT = DISTINCT = ORDER BY = LIMIT.
Поэтому мы смогли использовать Стоимость и в HAVING и в ORDER BY . 
В PostgreSQL мы такое не сможем провернуть в HAVING .*/





/* Посчитать стоимость всех экземпляров каждого автора без учета
 книг «Идиот» и «Белая гвардия». В результат включить только тех авторов,
 у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия»)
 более 5000 руб. Вычисляемый столбец назвать Стоимость. 
 Результат отсортировать по убыванию стоимости. */

 SELECT
    author,
    SUM(price * amount) AS Стоимость
FROM
    book
WHERE
    title != "Идиот" AND title != "Белая гвардия"
GROUP BY
    author
HAVING
    Стоимость > 5000
ORDER BY
    Стоимость DESC




-- Вложенные запросы
/* Вложенный запрос используется для выборки данных, которые будут 
использоваться в условии отбора записей основного запроса. 
Его применяют для:

сравнения выражения с результатом вложенного запроса;
определения того, включено ли выражение в результаты вложенного запроса;
проверки того, выбирает ли запрос определенные строки. */



-- Вывести информацию о самых дешевых книгах, хранящихся на складе.

SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );



/* Вывести информацию (автора, название и цену) о  книгах, цены которых 
меньше или равны средней цене книг на складе. Информацию вывести 
в отсортированном по убыванию цены виде. Среднее вычислить как среднее 
по цене книги. */

SELECT
    author,
    title,
    price
FROM
    book
WHERE
    price <=
        (SELECT
            AVG(price)
        FROM
            book)
ORDER BY
    price DESC



-- Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12.

SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );



-- Вложенный запрос, операторы ANY и ALL
/* При использовании оператора ANY в результирующую таблицу будут включены 
все записи, для которых  выражение со знаком отношения верно хотя бы 
для одного элемента результирующего запроса. Как работает оператор ANY():

amount > ANY (10, 12) эквивалентно amount > 10
amount < ANY (10, 12) эквивалентно amount < 12
amount = ANY (10, 12) эквивалентно (amount = 10) OR (amount = 12), а также amount IN  (10,12)
amount <> ANY (10, 12) вернет все записи с любым значением amount, включая 10 и 12

При использовании оператора ALL в результирующую таблицу будут включены 
все записи, для которых  выражение со знаком отношения верно для 
всех элементов результирующего запроса. Как работает оператор ALL:

amount > ALL (10, 12) эквивалентно amount > 12
amount < ALL (10, 12) эквивалентно amount < 10
amount = ALL (10, 12) не вернет ни одной записи, так как эквивалентно (amount = 10) AND (amount = 12)
amount <> ALL (10, 12) вернет все записи кроме тех,  в которыхamount равно 10 или 12

Важно! Операторы ALL и ANY можно использовать только с вложенными запросами. */